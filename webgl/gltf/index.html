<!DOCTYPE html>

<head>
  <style>
    html, body { width:100%; height:100%; margin:0; padding:0; }
    canvas { display:block; }
    #panel { position: absolute; top: 10px; left: 10px; color: white; background-color:rgba(0.3, 0.3, 0.3, 0.3); padding: 0.5em; max-width: 400px;}
  </style>
</head>

<body>
    <div id="panel">
      <strong>Basis Texture Transcoder glTF Demo</strong>
      <div id="log"></div>
  
    </div>
  <script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.135.0';
    import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.135.0/examples/jsm/loaders/GLTFLoader.js';
    import { KTX2Loader } from 'https://cdn.skypack.dev/three@0.135.0/examples/jsm/loaders/KTX2Loader.js';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.135.0/examples/jsm/controls/OrbitControls.js';

    const renderer = new THREE.WebGLRenderer( { antialias: true } );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.outputEncoding = THREE.sRGBEncoding;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color( 0xf0f0f0 );

    const light = new THREE.AmbientLight();
    scene.add( light );

    const light2 = new THREE.PointLight();
    scene.add( light2 );

    const camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 100 );
    camera.position.set( 8, 6, 5 );
    camera.lookAt( new THREE.Vector3( 0, -2, 0 ) );

    const controls = new OrbitControls( camera, renderer.domElement );
    controls.autoRotate = true;

    // Create KTX2Loader and detect supported target formats.

    const ktx2Loader = new KTX2Loader()
      .setTranscoderPath( '../transcoder/build/' )
      .detectSupport( renderer );

    // Create GLTFLoader, load model, and render.

    const loader = new GLTFLoader()
      .setKTX2Loader( ktx2Loader );

    loader.load( 'assets/AgiHqSmall.gltf', ( gltf ) => {

      const model = gltf.scene;
      model.scale.set( 0.01, 0.01, 0.01 );

      detectFormat( model );

      scene.add( model );

      document.body.appendChild( renderer.domElement );

      animate();

    }, undefined, ( e ) => console.error( e ) );

    // Main render loop.

    function animate() {

      requestAnimationFrame( animate );
      controls.update();
      renderer.render( scene, camera );

    }

    // Support viewport resizing.

    window.addEventListener( 'resize', () => {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize( window.innerWidth, window.innerHeight );

    }, false );

    function log(s) {

      const div = document.createElement('div');
      div.innerHTML = s;
      document.getElementById('log').appendChild(div);

    }

    function detectFormat( scene ) {

      const formatStrings = {
        [ THREE.RGBAFormat ]: "RGBA32",
        [ THREE.RGBA_BPTC_Format ]: "RGBA_BPTC",
        [ THREE.RGBA_ASTC_4x4_Format ]: "RGBA_ASTC_4x4",
        [ THREE.RGB_S3TC_DXT1_Format ]: "RGB_S3TC_DXT1",
        [ THREE.RGBA_S3TC_DXT5_Format ]: "RGBA_S3TC_DXT5",
        [ THREE.RGB_PVRTC_4BPPV1_Format ]: "RGB_PVRTC_4BPPV1",
        [ THREE.RGBA_PVRTC_4BPPV1_Format ]: "RGBA_PVRTC_4BPPV1",
        [ THREE.RGB_ETC1_Format ]: "RGB_ETC1",
        [ THREE.RGB_ETC2_Format ]: "RGB_ETC2",
        [ THREE.RGBA_ETC2_EAC_Format ]: "RGB_ETC2_EAC",
      };

      let formatName = 'Unknown format';

      scene.traverse( ( object ) => {

        if ( object.material && object.material.map ) {

          formatName = formatStrings[ object.material.map.format ];

        }

      } );

      log(`Transcode to: <strong>${formatName}</strong>`);

    }
  </script>
  
</body>

</html>
